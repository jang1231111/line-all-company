// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'road_name_address.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$RoadNameAddress {

 String? get detBdNmList;// 상세건물명 리스트
 String get emdNm;// 읍/면/동
 String get rn;// 도로명
 String get emdNo;// 읍면동일련번호
 String get siNm;// 시/도
 String get sggNm;// 시/군/구
 String get admCd;// 행정구역코드
 String get roadAddr;// 도로명 전체 주소
 String get lnbrMnnm;// 지번본번
 String get lnbrSlno;// 지번부번
 String get hstryYn;// 변경이력여부
 String? get relJibun;// 관련지번
 String get bdKdcd;// 건물관리번호구분코드
 String get rnMgtSn;// 도로명코드
 String? get liNm;// 리명
 String get bdMgtSn;// 건물관리번호
 String get engAddr;// 영문 주소
 String get zipNo;// 우편번호
 String? get roadAddrPart2;// 도로명 주소(뒷부분)
 String get jibunAddr;// 지번 주소
 String get roadAddrPart1;// 도로명 주소(앞부분)
 String? get bdNm;// 건물명
 String get udrtYn;// 지하여부
 String? get hemdNm;// 행정동명
 String get buldMnnm;// 건물본번
 String get mtYn;// 산여부
 String get buldSlno;
/// Create a copy of RoadNameAddress
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RoadNameAddressCopyWith<RoadNameAddress> get copyWith => _$RoadNameAddressCopyWithImpl<RoadNameAddress>(this as RoadNameAddress, _$identity);

  /// Serializes this RoadNameAddress to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RoadNameAddress&&(identical(other.detBdNmList, detBdNmList) || other.detBdNmList == detBdNmList)&&(identical(other.emdNm, emdNm) || other.emdNm == emdNm)&&(identical(other.rn, rn) || other.rn == rn)&&(identical(other.emdNo, emdNo) || other.emdNo == emdNo)&&(identical(other.siNm, siNm) || other.siNm == siNm)&&(identical(other.sggNm, sggNm) || other.sggNm == sggNm)&&(identical(other.admCd, admCd) || other.admCd == admCd)&&(identical(other.roadAddr, roadAddr) || other.roadAddr == roadAddr)&&(identical(other.lnbrMnnm, lnbrMnnm) || other.lnbrMnnm == lnbrMnnm)&&(identical(other.lnbrSlno, lnbrSlno) || other.lnbrSlno == lnbrSlno)&&(identical(other.hstryYn, hstryYn) || other.hstryYn == hstryYn)&&(identical(other.relJibun, relJibun) || other.relJibun == relJibun)&&(identical(other.bdKdcd, bdKdcd) || other.bdKdcd == bdKdcd)&&(identical(other.rnMgtSn, rnMgtSn) || other.rnMgtSn == rnMgtSn)&&(identical(other.liNm, liNm) || other.liNm == liNm)&&(identical(other.bdMgtSn, bdMgtSn) || other.bdMgtSn == bdMgtSn)&&(identical(other.engAddr, engAddr) || other.engAddr == engAddr)&&(identical(other.zipNo, zipNo) || other.zipNo == zipNo)&&(identical(other.roadAddrPart2, roadAddrPart2) || other.roadAddrPart2 == roadAddrPart2)&&(identical(other.jibunAddr, jibunAddr) || other.jibunAddr == jibunAddr)&&(identical(other.roadAddrPart1, roadAddrPart1) || other.roadAddrPart1 == roadAddrPart1)&&(identical(other.bdNm, bdNm) || other.bdNm == bdNm)&&(identical(other.udrtYn, udrtYn) || other.udrtYn == udrtYn)&&(identical(other.hemdNm, hemdNm) || other.hemdNm == hemdNm)&&(identical(other.buldMnnm, buldMnnm) || other.buldMnnm == buldMnnm)&&(identical(other.mtYn, mtYn) || other.mtYn == mtYn)&&(identical(other.buldSlno, buldSlno) || other.buldSlno == buldSlno));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,detBdNmList,emdNm,rn,emdNo,siNm,sggNm,admCd,roadAddr,lnbrMnnm,lnbrSlno,hstryYn,relJibun,bdKdcd,rnMgtSn,liNm,bdMgtSn,engAddr,zipNo,roadAddrPart2,jibunAddr,roadAddrPart1,bdNm,udrtYn,hemdNm,buldMnnm,mtYn,buldSlno]);

@override
String toString() {
  return 'RoadNameAddress(detBdNmList: $detBdNmList, emdNm: $emdNm, rn: $rn, emdNo: $emdNo, siNm: $siNm, sggNm: $sggNm, admCd: $admCd, roadAddr: $roadAddr, lnbrMnnm: $lnbrMnnm, lnbrSlno: $lnbrSlno, hstryYn: $hstryYn, relJibun: $relJibun, bdKdcd: $bdKdcd, rnMgtSn: $rnMgtSn, liNm: $liNm, bdMgtSn: $bdMgtSn, engAddr: $engAddr, zipNo: $zipNo, roadAddrPart2: $roadAddrPart2, jibunAddr: $jibunAddr, roadAddrPart1: $roadAddrPart1, bdNm: $bdNm, udrtYn: $udrtYn, hemdNm: $hemdNm, buldMnnm: $buldMnnm, mtYn: $mtYn, buldSlno: $buldSlno)';
}


}

/// @nodoc
abstract mixin class $RoadNameAddressCopyWith<$Res>  {
  factory $RoadNameAddressCopyWith(RoadNameAddress value, $Res Function(RoadNameAddress) _then) = _$RoadNameAddressCopyWithImpl;
@useResult
$Res call({
 String? detBdNmList, String emdNm, String rn, String emdNo, String siNm, String sggNm, String admCd, String roadAddr, String lnbrMnnm, String lnbrSlno, String hstryYn, String? relJibun, String bdKdcd, String rnMgtSn, String? liNm, String bdMgtSn, String engAddr, String zipNo, String? roadAddrPart2, String jibunAddr, String roadAddrPart1, String? bdNm, String udrtYn, String? hemdNm, String buldMnnm, String mtYn, String buldSlno
});




}
/// @nodoc
class _$RoadNameAddressCopyWithImpl<$Res>
    implements $RoadNameAddressCopyWith<$Res> {
  _$RoadNameAddressCopyWithImpl(this._self, this._then);

  final RoadNameAddress _self;
  final $Res Function(RoadNameAddress) _then;

/// Create a copy of RoadNameAddress
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? detBdNmList = freezed,Object? emdNm = null,Object? rn = null,Object? emdNo = null,Object? siNm = null,Object? sggNm = null,Object? admCd = null,Object? roadAddr = null,Object? lnbrMnnm = null,Object? lnbrSlno = null,Object? hstryYn = null,Object? relJibun = freezed,Object? bdKdcd = null,Object? rnMgtSn = null,Object? liNm = freezed,Object? bdMgtSn = null,Object? engAddr = null,Object? zipNo = null,Object? roadAddrPart2 = freezed,Object? jibunAddr = null,Object? roadAddrPart1 = null,Object? bdNm = freezed,Object? udrtYn = null,Object? hemdNm = freezed,Object? buldMnnm = null,Object? mtYn = null,Object? buldSlno = null,}) {
  return _then(_self.copyWith(
detBdNmList: freezed == detBdNmList ? _self.detBdNmList : detBdNmList // ignore: cast_nullable_to_non_nullable
as String?,emdNm: null == emdNm ? _self.emdNm : emdNm // ignore: cast_nullable_to_non_nullable
as String,rn: null == rn ? _self.rn : rn // ignore: cast_nullable_to_non_nullable
as String,emdNo: null == emdNo ? _self.emdNo : emdNo // ignore: cast_nullable_to_non_nullable
as String,siNm: null == siNm ? _self.siNm : siNm // ignore: cast_nullable_to_non_nullable
as String,sggNm: null == sggNm ? _self.sggNm : sggNm // ignore: cast_nullable_to_non_nullable
as String,admCd: null == admCd ? _self.admCd : admCd // ignore: cast_nullable_to_non_nullable
as String,roadAddr: null == roadAddr ? _self.roadAddr : roadAddr // ignore: cast_nullable_to_non_nullable
as String,lnbrMnnm: null == lnbrMnnm ? _self.lnbrMnnm : lnbrMnnm // ignore: cast_nullable_to_non_nullable
as String,lnbrSlno: null == lnbrSlno ? _self.lnbrSlno : lnbrSlno // ignore: cast_nullable_to_non_nullable
as String,hstryYn: null == hstryYn ? _self.hstryYn : hstryYn // ignore: cast_nullable_to_non_nullable
as String,relJibun: freezed == relJibun ? _self.relJibun : relJibun // ignore: cast_nullable_to_non_nullable
as String?,bdKdcd: null == bdKdcd ? _self.bdKdcd : bdKdcd // ignore: cast_nullable_to_non_nullable
as String,rnMgtSn: null == rnMgtSn ? _self.rnMgtSn : rnMgtSn // ignore: cast_nullable_to_non_nullable
as String,liNm: freezed == liNm ? _self.liNm : liNm // ignore: cast_nullable_to_non_nullable
as String?,bdMgtSn: null == bdMgtSn ? _self.bdMgtSn : bdMgtSn // ignore: cast_nullable_to_non_nullable
as String,engAddr: null == engAddr ? _self.engAddr : engAddr // ignore: cast_nullable_to_non_nullable
as String,zipNo: null == zipNo ? _self.zipNo : zipNo // ignore: cast_nullable_to_non_nullable
as String,roadAddrPart2: freezed == roadAddrPart2 ? _self.roadAddrPart2 : roadAddrPart2 // ignore: cast_nullable_to_non_nullable
as String?,jibunAddr: null == jibunAddr ? _self.jibunAddr : jibunAddr // ignore: cast_nullable_to_non_nullable
as String,roadAddrPart1: null == roadAddrPart1 ? _self.roadAddrPart1 : roadAddrPart1 // ignore: cast_nullable_to_non_nullable
as String,bdNm: freezed == bdNm ? _self.bdNm : bdNm // ignore: cast_nullable_to_non_nullable
as String?,udrtYn: null == udrtYn ? _self.udrtYn : udrtYn // ignore: cast_nullable_to_non_nullable
as String,hemdNm: freezed == hemdNm ? _self.hemdNm : hemdNm // ignore: cast_nullable_to_non_nullable
as String?,buldMnnm: null == buldMnnm ? _self.buldMnnm : buldMnnm // ignore: cast_nullable_to_non_nullable
as String,mtYn: null == mtYn ? _self.mtYn : mtYn // ignore: cast_nullable_to_non_nullable
as String,buldSlno: null == buldSlno ? _self.buldSlno : buldSlno // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [RoadNameAddress].
extension RoadNameAddressPatterns on RoadNameAddress {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _RoadNameAddress value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _RoadNameAddress() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _RoadNameAddress value)  $default,){
final _that = this;
switch (_that) {
case _RoadNameAddress():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _RoadNameAddress value)?  $default,){
final _that = this;
switch (_that) {
case _RoadNameAddress() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String? detBdNmList,  String emdNm,  String rn,  String emdNo,  String siNm,  String sggNm,  String admCd,  String roadAddr,  String lnbrMnnm,  String lnbrSlno,  String hstryYn,  String? relJibun,  String bdKdcd,  String rnMgtSn,  String? liNm,  String bdMgtSn,  String engAddr,  String zipNo,  String? roadAddrPart2,  String jibunAddr,  String roadAddrPart1,  String? bdNm,  String udrtYn,  String? hemdNm,  String buldMnnm,  String mtYn,  String buldSlno)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _RoadNameAddress() when $default != null:
return $default(_that.detBdNmList,_that.emdNm,_that.rn,_that.emdNo,_that.siNm,_that.sggNm,_that.admCd,_that.roadAddr,_that.lnbrMnnm,_that.lnbrSlno,_that.hstryYn,_that.relJibun,_that.bdKdcd,_that.rnMgtSn,_that.liNm,_that.bdMgtSn,_that.engAddr,_that.zipNo,_that.roadAddrPart2,_that.jibunAddr,_that.roadAddrPart1,_that.bdNm,_that.udrtYn,_that.hemdNm,_that.buldMnnm,_that.mtYn,_that.buldSlno);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String? detBdNmList,  String emdNm,  String rn,  String emdNo,  String siNm,  String sggNm,  String admCd,  String roadAddr,  String lnbrMnnm,  String lnbrSlno,  String hstryYn,  String? relJibun,  String bdKdcd,  String rnMgtSn,  String? liNm,  String bdMgtSn,  String engAddr,  String zipNo,  String? roadAddrPart2,  String jibunAddr,  String roadAddrPart1,  String? bdNm,  String udrtYn,  String? hemdNm,  String buldMnnm,  String mtYn,  String buldSlno)  $default,) {final _that = this;
switch (_that) {
case _RoadNameAddress():
return $default(_that.detBdNmList,_that.emdNm,_that.rn,_that.emdNo,_that.siNm,_that.sggNm,_that.admCd,_that.roadAddr,_that.lnbrMnnm,_that.lnbrSlno,_that.hstryYn,_that.relJibun,_that.bdKdcd,_that.rnMgtSn,_that.liNm,_that.bdMgtSn,_that.engAddr,_that.zipNo,_that.roadAddrPart2,_that.jibunAddr,_that.roadAddrPart1,_that.bdNm,_that.udrtYn,_that.hemdNm,_that.buldMnnm,_that.mtYn,_that.buldSlno);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String? detBdNmList,  String emdNm,  String rn,  String emdNo,  String siNm,  String sggNm,  String admCd,  String roadAddr,  String lnbrMnnm,  String lnbrSlno,  String hstryYn,  String? relJibun,  String bdKdcd,  String rnMgtSn,  String? liNm,  String bdMgtSn,  String engAddr,  String zipNo,  String? roadAddrPart2,  String jibunAddr,  String roadAddrPart1,  String? bdNm,  String udrtYn,  String? hemdNm,  String buldMnnm,  String mtYn,  String buldSlno)?  $default,) {final _that = this;
switch (_that) {
case _RoadNameAddress() when $default != null:
return $default(_that.detBdNmList,_that.emdNm,_that.rn,_that.emdNo,_that.siNm,_that.sggNm,_that.admCd,_that.roadAddr,_that.lnbrMnnm,_that.lnbrSlno,_that.hstryYn,_that.relJibun,_that.bdKdcd,_that.rnMgtSn,_that.liNm,_that.bdMgtSn,_that.engAddr,_that.zipNo,_that.roadAddrPart2,_that.jibunAddr,_that.roadAddrPart1,_that.bdNm,_that.udrtYn,_that.hemdNm,_that.buldMnnm,_that.mtYn,_that.buldSlno);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _RoadNameAddress implements RoadNameAddress {
  const _RoadNameAddress({this.detBdNmList, required this.emdNm, required this.rn, required this.emdNo, required this.siNm, required this.sggNm, required this.admCd, required this.roadAddr, required this.lnbrMnnm, required this.lnbrSlno, required this.hstryYn, this.relJibun, required this.bdKdcd, required this.rnMgtSn, this.liNm, required this.bdMgtSn, required this.engAddr, required this.zipNo, this.roadAddrPart2, required this.jibunAddr, required this.roadAddrPart1, this.bdNm, required this.udrtYn, this.hemdNm, required this.buldMnnm, required this.mtYn, required this.buldSlno});
  factory _RoadNameAddress.fromJson(Map<String, dynamic> json) => _$RoadNameAddressFromJson(json);

@override final  String? detBdNmList;
// 상세건물명 리스트
@override final  String emdNm;
// 읍/면/동
@override final  String rn;
// 도로명
@override final  String emdNo;
// 읍면동일련번호
@override final  String siNm;
// 시/도
@override final  String sggNm;
// 시/군/구
@override final  String admCd;
// 행정구역코드
@override final  String roadAddr;
// 도로명 전체 주소
@override final  String lnbrMnnm;
// 지번본번
@override final  String lnbrSlno;
// 지번부번
@override final  String hstryYn;
// 변경이력여부
@override final  String? relJibun;
// 관련지번
@override final  String bdKdcd;
// 건물관리번호구분코드
@override final  String rnMgtSn;
// 도로명코드
@override final  String? liNm;
// 리명
@override final  String bdMgtSn;
// 건물관리번호
@override final  String engAddr;
// 영문 주소
@override final  String zipNo;
// 우편번호
@override final  String? roadAddrPart2;
// 도로명 주소(뒷부분)
@override final  String jibunAddr;
// 지번 주소
@override final  String roadAddrPart1;
// 도로명 주소(앞부분)
@override final  String? bdNm;
// 건물명
@override final  String udrtYn;
// 지하여부
@override final  String? hemdNm;
// 행정동명
@override final  String buldMnnm;
// 건물본번
@override final  String mtYn;
// 산여부
@override final  String buldSlno;

/// Create a copy of RoadNameAddress
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RoadNameAddressCopyWith<_RoadNameAddress> get copyWith => __$RoadNameAddressCopyWithImpl<_RoadNameAddress>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RoadNameAddressToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RoadNameAddress&&(identical(other.detBdNmList, detBdNmList) || other.detBdNmList == detBdNmList)&&(identical(other.emdNm, emdNm) || other.emdNm == emdNm)&&(identical(other.rn, rn) || other.rn == rn)&&(identical(other.emdNo, emdNo) || other.emdNo == emdNo)&&(identical(other.siNm, siNm) || other.siNm == siNm)&&(identical(other.sggNm, sggNm) || other.sggNm == sggNm)&&(identical(other.admCd, admCd) || other.admCd == admCd)&&(identical(other.roadAddr, roadAddr) || other.roadAddr == roadAddr)&&(identical(other.lnbrMnnm, lnbrMnnm) || other.lnbrMnnm == lnbrMnnm)&&(identical(other.lnbrSlno, lnbrSlno) || other.lnbrSlno == lnbrSlno)&&(identical(other.hstryYn, hstryYn) || other.hstryYn == hstryYn)&&(identical(other.relJibun, relJibun) || other.relJibun == relJibun)&&(identical(other.bdKdcd, bdKdcd) || other.bdKdcd == bdKdcd)&&(identical(other.rnMgtSn, rnMgtSn) || other.rnMgtSn == rnMgtSn)&&(identical(other.liNm, liNm) || other.liNm == liNm)&&(identical(other.bdMgtSn, bdMgtSn) || other.bdMgtSn == bdMgtSn)&&(identical(other.engAddr, engAddr) || other.engAddr == engAddr)&&(identical(other.zipNo, zipNo) || other.zipNo == zipNo)&&(identical(other.roadAddrPart2, roadAddrPart2) || other.roadAddrPart2 == roadAddrPart2)&&(identical(other.jibunAddr, jibunAddr) || other.jibunAddr == jibunAddr)&&(identical(other.roadAddrPart1, roadAddrPart1) || other.roadAddrPart1 == roadAddrPart1)&&(identical(other.bdNm, bdNm) || other.bdNm == bdNm)&&(identical(other.udrtYn, udrtYn) || other.udrtYn == udrtYn)&&(identical(other.hemdNm, hemdNm) || other.hemdNm == hemdNm)&&(identical(other.buldMnnm, buldMnnm) || other.buldMnnm == buldMnnm)&&(identical(other.mtYn, mtYn) || other.mtYn == mtYn)&&(identical(other.buldSlno, buldSlno) || other.buldSlno == buldSlno));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,detBdNmList,emdNm,rn,emdNo,siNm,sggNm,admCd,roadAddr,lnbrMnnm,lnbrSlno,hstryYn,relJibun,bdKdcd,rnMgtSn,liNm,bdMgtSn,engAddr,zipNo,roadAddrPart2,jibunAddr,roadAddrPart1,bdNm,udrtYn,hemdNm,buldMnnm,mtYn,buldSlno]);

@override
String toString() {
  return 'RoadNameAddress(detBdNmList: $detBdNmList, emdNm: $emdNm, rn: $rn, emdNo: $emdNo, siNm: $siNm, sggNm: $sggNm, admCd: $admCd, roadAddr: $roadAddr, lnbrMnnm: $lnbrMnnm, lnbrSlno: $lnbrSlno, hstryYn: $hstryYn, relJibun: $relJibun, bdKdcd: $bdKdcd, rnMgtSn: $rnMgtSn, liNm: $liNm, bdMgtSn: $bdMgtSn, engAddr: $engAddr, zipNo: $zipNo, roadAddrPart2: $roadAddrPart2, jibunAddr: $jibunAddr, roadAddrPart1: $roadAddrPart1, bdNm: $bdNm, udrtYn: $udrtYn, hemdNm: $hemdNm, buldMnnm: $buldMnnm, mtYn: $mtYn, buldSlno: $buldSlno)';
}


}

/// @nodoc
abstract mixin class _$RoadNameAddressCopyWith<$Res> implements $RoadNameAddressCopyWith<$Res> {
  factory _$RoadNameAddressCopyWith(_RoadNameAddress value, $Res Function(_RoadNameAddress) _then) = __$RoadNameAddressCopyWithImpl;
@override @useResult
$Res call({
 String? detBdNmList, String emdNm, String rn, String emdNo, String siNm, String sggNm, String admCd, String roadAddr, String lnbrMnnm, String lnbrSlno, String hstryYn, String? relJibun, String bdKdcd, String rnMgtSn, String? liNm, String bdMgtSn, String engAddr, String zipNo, String? roadAddrPart2, String jibunAddr, String roadAddrPart1, String? bdNm, String udrtYn, String? hemdNm, String buldMnnm, String mtYn, String buldSlno
});




}
/// @nodoc
class __$RoadNameAddressCopyWithImpl<$Res>
    implements _$RoadNameAddressCopyWith<$Res> {
  __$RoadNameAddressCopyWithImpl(this._self, this._then);

  final _RoadNameAddress _self;
  final $Res Function(_RoadNameAddress) _then;

/// Create a copy of RoadNameAddress
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? detBdNmList = freezed,Object? emdNm = null,Object? rn = null,Object? emdNo = null,Object? siNm = null,Object? sggNm = null,Object? admCd = null,Object? roadAddr = null,Object? lnbrMnnm = null,Object? lnbrSlno = null,Object? hstryYn = null,Object? relJibun = freezed,Object? bdKdcd = null,Object? rnMgtSn = null,Object? liNm = freezed,Object? bdMgtSn = null,Object? engAddr = null,Object? zipNo = null,Object? roadAddrPart2 = freezed,Object? jibunAddr = null,Object? roadAddrPart1 = null,Object? bdNm = freezed,Object? udrtYn = null,Object? hemdNm = freezed,Object? buldMnnm = null,Object? mtYn = null,Object? buldSlno = null,}) {
  return _then(_RoadNameAddress(
detBdNmList: freezed == detBdNmList ? _self.detBdNmList : detBdNmList // ignore: cast_nullable_to_non_nullable
as String?,emdNm: null == emdNm ? _self.emdNm : emdNm // ignore: cast_nullable_to_non_nullable
as String,rn: null == rn ? _self.rn : rn // ignore: cast_nullable_to_non_nullable
as String,emdNo: null == emdNo ? _self.emdNo : emdNo // ignore: cast_nullable_to_non_nullable
as String,siNm: null == siNm ? _self.siNm : siNm // ignore: cast_nullable_to_non_nullable
as String,sggNm: null == sggNm ? _self.sggNm : sggNm // ignore: cast_nullable_to_non_nullable
as String,admCd: null == admCd ? _self.admCd : admCd // ignore: cast_nullable_to_non_nullable
as String,roadAddr: null == roadAddr ? _self.roadAddr : roadAddr // ignore: cast_nullable_to_non_nullable
as String,lnbrMnnm: null == lnbrMnnm ? _self.lnbrMnnm : lnbrMnnm // ignore: cast_nullable_to_non_nullable
as String,lnbrSlno: null == lnbrSlno ? _self.lnbrSlno : lnbrSlno // ignore: cast_nullable_to_non_nullable
as String,hstryYn: null == hstryYn ? _self.hstryYn : hstryYn // ignore: cast_nullable_to_non_nullable
as String,relJibun: freezed == relJibun ? _self.relJibun : relJibun // ignore: cast_nullable_to_non_nullable
as String?,bdKdcd: null == bdKdcd ? _self.bdKdcd : bdKdcd // ignore: cast_nullable_to_non_nullable
as String,rnMgtSn: null == rnMgtSn ? _self.rnMgtSn : rnMgtSn // ignore: cast_nullable_to_non_nullable
as String,liNm: freezed == liNm ? _self.liNm : liNm // ignore: cast_nullable_to_non_nullable
as String?,bdMgtSn: null == bdMgtSn ? _self.bdMgtSn : bdMgtSn // ignore: cast_nullable_to_non_nullable
as String,engAddr: null == engAddr ? _self.engAddr : engAddr // ignore: cast_nullable_to_non_nullable
as String,zipNo: null == zipNo ? _self.zipNo : zipNo // ignore: cast_nullable_to_non_nullable
as String,roadAddrPart2: freezed == roadAddrPart2 ? _self.roadAddrPart2 : roadAddrPart2 // ignore: cast_nullable_to_non_nullable
as String?,jibunAddr: null == jibunAddr ? _self.jibunAddr : jibunAddr // ignore: cast_nullable_to_non_nullable
as String,roadAddrPart1: null == roadAddrPart1 ? _self.roadAddrPart1 : roadAddrPart1 // ignore: cast_nullable_to_non_nullable
as String,bdNm: freezed == bdNm ? _self.bdNm : bdNm // ignore: cast_nullable_to_non_nullable
as String?,udrtYn: null == udrtYn ? _self.udrtYn : udrtYn // ignore: cast_nullable_to_non_nullable
as String,hemdNm: freezed == hemdNm ? _self.hemdNm : hemdNm // ignore: cast_nullable_to_non_nullable
as String?,buldMnnm: null == buldMnnm ? _self.buldMnnm : buldMnnm // ignore: cast_nullable_to_non_nullable
as String,mtYn: null == mtYn ? _self.mtYn : mtYn // ignore: cast_nullable_to_non_nullable
as String,buldSlno: null == buldSlno ? _self.buldSlno : buldSlno // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on
